<html>
  <head>
    <meta charset="utf-8">
    <title> Home | ben.kirw.in </title>
    <link rel="stylesheet" type="text/css" href="/css/main.css"></link>
    <link rel="stylesheet" type="text/css" href="/css/kate-highlighting.css"></link>
    <!--
    <link href='http://fonts.googleapis.com/css?family=Open+Sans' rel='stylesheet' type='text/css'>
    <link href='http://fonts.googleapis.com/css?family=PT+Sans+Narrow:700' rel='stylesheet' type='text/css'>
    -->
  </head>
  <body>
    <div class="content">
      <header>
        <img src="/img/construction.gif"></img>
        <nav><ul>
          <li><a href="/">home</a></li>
          <li><a href="/about/">about</a></li>
        </ul></nav>
      </header>
      
<article>
  <h1> <a href="/2016/08/27/barely-functional-3-merkle/"> Barely Functional #3 </a> </h1>
  <h2> <a href="/2016/08/27/barely-functional-3-merkle/"> Tries and Failures</a> </h2>
  <p> <p>Well, time flies! It’s well over a year ago that I promised to continue my writeups on the <code>ethereum-haskell</code> project with some notes on the merkle trie implementation – but it’s been a long time since I’ve had time or inclination to chip at that project, and my notes have been collecting dust.</p> </p>
</article>

<article>
  <h1> <a href="/2015/05/26/coast-announce/"> Releasing Coast </a> </h1>
  <h2> <a href="/2015/05/26/coast-announce/"> Samza, Cycles, and Streaming for People</a> </h2>
  <p> <p>Today, I’m delighted to announce the 0.2 release of <a href="https://github.com/bkirwi/coast">the <code>coast</code> project</a>: a high-level streaming toolkit written in Scala. <code>coast</code> is designed around Kafka’s partitioned log model, and supports complex streaming topologies with unusually strong messaging guarantees and no need for a central coordinator. The current release includes a new backend that compiles to <a href="https://samza.apache.org/">Samza</a> and supports exactly-once semantics for messages and state, support for cyclic dataflow graphs, and a bunch of improvements to the core library and documentation.</p> </p>
</article>

<article>
  <h1> <a href="/2014/11/28/kafka-patterns/"> Doing the Impossible </a> </h1>
  <h2> <a href="/2014/11/28/kafka-patterns/"> Exactly-once Messaging Patterns in Kafka</a> </h2>
  <p> <p>Exactly-once messaging is something of a holy grail in the Kafka ecosystem – widely sought-after but rarely encountered. There are a handful of systems that promise exactly-once semantics, but none of them are a general-purpose solution: they’re often too task-specific, too heavyweight, or too broken, and sometimes all three. Complicating the picture is the fact that exactly-once message delivery is, in general, impossible.</p> </p>
</article>

<article>
  <h1> <a href="/2014/08/14/barely-functional-2-convertible/"> Barely Functional #2 </a> </h1>
  <h2> <a href="/2014/08/14/barely-functional-2-convertible/"> Structuring Data and Scrapping Boilerplate</a> </h2>
  <p> <p>This is my second post on a Haskell codebase I’ve been working on – a reimplementation of the <a href="https://ethereum.org/">Ethereum cryptocurrency / application platform</a> in Haskell. (If you missed it, you might want to read <a href="/2014/06/24/barely-functional-1-rlp/">the original post</a> first.) Like last time, we’ll take some ideas from the original project, look at how they translate into Haskell, and compare things with one of the official implementations.</p> </p>
</article>

<article>
  <h1> <a href="/2014/06/24/barely-functional-1-rlp/"> Barely Functional #1 </a> </h1>
  <h2> <a href="/2014/06/24/barely-functional-1-rlp/"> Writing a Real Program in Haskell</a> </h2>
  <p> <p>A lot of folks have been complaining about the gap between knowing elementary Haskell — the sort you learn in language tutorials — and real-world programming. Even when you’re comfortable with the core language, it’s not always obvious where to go from there, or how to translate those ideas into a larger system.</p> </p>
</article>


    </div>
  </body>
</html>
