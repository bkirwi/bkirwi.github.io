<html>
  <head>
    <meta charset="utf-8">
    <title> Home | ben.kirw.in </title>
    <link rel="stylesheet" type="text/css" href="/css/main.css"></link>
    <link rel="stylesheet" type="text/css" href="/css/kate-highlighting.css"></link>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Source+Code+Pro&amp;family=Source+Serif+Pro:ital,wght@0,400;0,600;1,400&amp;display=swap" rel="stylesheet">
  </head>
  <body>
    <div class="content">
      <header>
        <img src="/img/construction.gif"></img>
        <nav><ul>
          <li><a href="/">home</a></li>
          <li><a href="/about/">about</a></li>
        </ul></nav>
      </header>
      
<article>
  <h1> <a href="/2022/04/28/decline/"> Five years of decline </a> </h1>
  <h2> <a href="/2022/04/28/decline/"> (the command-line parsing library)</a> </h2>
  <p> <p>It’s been a little over five years since I first published <code>decline</code>, a functional and UNIXy command-line parser for Scala. (If you’re not familiar with <code>decline</code>, <a href="http://monovore.com/decline/">the documentation might help</a>.)</p> </p>
</article>

<article>
  <h1> <a href="/2018/12/02/hash-range-partitioning/"> Hash-Range Partitioning </a> </h1>
  <h2> <a href="/2018/12/02/hash-range-partitioning/"> Better partitioning for distributed data</a> </h2>
  <p> <p>In distributed systems, it’s extroardinarily common to want to split a large dataset across some number of physical shards or partitions. This is commonly done by taking the key, hashing it, and then taking the hash modulo the number of partitions:</p> </p>
</article>

<article>
  <h1> <a href="/2015/05/26/coast-announce/"> Releasing Coast </a> </h1>
  <h2> <a href="/2015/05/26/coast-announce/"> Samza, Cycles, and Streaming for People</a> </h2>
  <p> <p>Today, I’m delighted to announce the 0.2 release of <a href="https://github.com/bkirwi/coast">the <code>coast</code> project</a>: a high-level streaming toolkit written in Scala. <code>coast</code> is designed around Kafka’s partitioned log model, and supports complex streaming topologies with unusually strong messaging guarantees and no need for a central coordinator. The current release includes a new backend that compiles to <a href="https://samza.apache.org/">Samza</a> and supports exactly-once semantics for messages and state, support for cyclic dataflow graphs, and a bunch of improvements to the core library and documentation.</p> </p>
</article>

<article>
  <h1> <a href="/2014/11/28/kafka-patterns/"> Doing the Impossible </a> </h1>
  <h2> <a href="/2014/11/28/kafka-patterns/"> Exactly-once Messaging Patterns in Kafka</a> </h2>
  <p> <p>Exactly-once messaging is something of a holy grail in the Kafka ecosystem – widely sought-after but rarely encountered. There are a handful of systems that promise exactly-once semantics, but none of them are a general-purpose solution: they’re often too task-specific, too heavyweight, or too broken, and sometimes all three. Complicating the picture is the fact that exactly-once message delivery is, in general, impossible.</p> </p>
</article>


    </div>
  </body>
</html>
